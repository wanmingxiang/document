| 字段名           | 数据类型           | 描述             | 压缩算法 |
| ---------------- | ------------------ | ---------------- | -------- |
| book_id          | INTEGER            | 图书ID，主键     |          |
| title            | VARCHAR(255)       | 图书标题         | zstd     |
| author           | ***VARCHAR(100)*** | 图书作者         |          |
| publication      | **VARCHAR(100)**   | 图书出版社       |          |
| publication_date | <u>DATE</u>        | 图书出版日期     |          |
| isbn             | VARCHAR(20)        | 图书的ISBN号码   |          |
| genre            | VARCHAR(50)        | 图书类型/流派    |          |
| language         | VARCHAR(50)        | 图书语言         |          |
| page_count       | INTEGER            | 图书页数         |          |
| cover_image      | VARCHAR(255)       | 图书封面图片链接 | zstd     |
| description      | TEXT               | 图书描述/摘要    | zstd     |
| average_rating   | DECIMAL(3, 2)      | 图书平均评分     |          |
| total_ratings    | INTEGER            | 总评分人数       |          |
|                  |                    |                  |          |
|                  |                    |                  |          |



根据上述数据类型大小，一行数据的大致空间占用如下：

4字节 + 255字节 + 100字节 + 4字节 + 20字节 + 50字节 + 4字节 + 255字节 + 8字节 + 8字节 = 大约716字节

10亿条数据的空间占用：716GB

空间占用：

按KV存储，存储宣称的压缩为3:1来算， 占用空间238G

按列存储， 列存的压缩比跟数据的分布、数据的类型选用的压缩算法都有关系，在重复数据较高的场景下有更好的压缩比，3~20倍不等， 对象抽取的维度一般可以用来分类的标签，重复度一般不会低，以6倍压缩比来推算，占用空间119G；

单次IO的粒度：

列存seq scan 通常较多，一般的数据块较大，以Redshift为例，定为1MB；

KV存储，以存储的Grain为单位，定为 8KB

PreFilter : 

KV：  KV必须要全表扫描，约238G

列存： 列存过滤通常跟数据排布、是否排序、数据类型相关，且有zone map等辅助手段， 最好的情况下，可能只需要扫描1个数据块，约1MB；

PostFilter:

KV:  以Top100为例， 考虑到结果可能被严格的筛选条件全过滤掉，放大2倍，会产生有200个8K的随机IO；

列存： 最好的情况下，排过序、重复度高，1MB的IO即可； 如果未排序的情况下，以“language"过滤条件为例， 其可以采用字典编码，1条数据理论上占2B即可，但是考虑到加上字典的空间，其他的元数据占用空间，不好准确估计，所以按4Byte计算，约3.78GB；所以其访问模型大概在1M ~ 3.78G的顺序IO访问；



倒排 

1，对文档建立倒排索引，空间占用较高，以lucene为例，约占文档的10%；

2， 对特定字段建立倒排，以langue为例， 以6000种语言为例，每个语种占4B算， 共10亿条数据，占空间约



